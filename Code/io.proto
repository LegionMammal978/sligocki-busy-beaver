// Protobuf messages used for storing TM search results on disk.
//
// This is meant to replace the existing ad-hoc text format used by IO.py.
//
// It provides the main advantage of being extensible, adding a new field
// for new stats is trivial and backwards/forwards compatible. It also
// has the potential to be more efficient for data storage ...

syntax = "proto3";

package busy_beaver;


// A "potentially" big positive integer.
message BigInt {
  oneof big_int {
    // If the int is small enough, it is stored as a uint64.
    uint64 int = 1;
    // If it is too big (>= 2^64), serialize it as a text string.
    //
    // Note: If we have a lot of these, we could consider a more efficient
    // format, like byte-packing into a bytes object ... but I think it is
    // uncommon enough, that using this inefficient solution is fine.
    string str = 2;
  }
}

message TuringMachine {
  // TODO: We may want to encode this in a more efficient way.
  // Ex: a bytes with transitions bit-packed into 1 byte each? (~4x smaller).
  string ttable = 1;
}


// Statuses for various searches (BB, BBB, ...)
message HaltStatus {
  // Have we made a halting decision?
  bool is_decided = 1;
  // Does this machine halt? (Only meaningful if is_decided = True)
  bool is_halting = 2;

  BigInt halt_steps = 3;
  BigInt halt_score = 4;
}

message QuasihaltStatus {
  // Have we made a quasihalting decision?
  bool is_decided = 1;
  // Does this machine quasihalt? (Only meaningful if is_decided = True)
  bool is_quasihalting = 2;

  BigInt quasihalt_steps = 3;
  int64 quasihalt_state = 4;
}

message Status {
  HaltStatus halt_status = 1;
  QuasihaltStatus quasihalt_status = 2;
  // TODO: Add more, like lin_recur_info and blanking_info?
}


// Filter Results
message SimulatorRequest {
  // Parameters
  // TODO
}

message SimulatorResponse {
  // Results
  // Reason simulator finished (Halt, Inf, Over_Steps, Error, ...)
  string sim_condition = 1;

  // Stats
  float elapsed_time_sec = 2;

  int64 num_loops = 3;
  BigInt num_steps = 4;

  int64 num_rules_proven = 5;
  int64 num_proofs_failed = 6;
}

message SimulatorResult {
  SimulatorRequest parameters = 1;
  SimulatorResponse result = 2;
}


message BlockFinderRequest {
  // # loops to run Sim searching for least-compressed tape.
  int64 compression_search_loops = 1;
  // # loops to run sim for each multiple of optimal compression size.
  int64 mult_sim_loops = 2;
  // While searching for optimal multiple: How far should we look beyond
  // current best mult?
  int64 extra_mult = 3;
}

message BlockFinderResponse {
  // Results
  // Overall heuristically decided best block size.
  int64 best_block_size = 1;

  // Stats
  float elapsed_time_sec = 2;

  // Chain Sim loop (with block size 1) where compressed tape was largest
  // (least effectively compressed).
  int64 least_compressed_loop = 3;
  // # Blocks (with compression) on this least compressed tape.
  int64 least_compressed_tape_size_chain = 4;
  // Total # symbols (no compression) on this least compressed tape.
  int64 least_compressed_tape_size_raw = 5;
  // Best block size for compression on this least compressed tape.
  int64 best_compression_block_size = 6;
  // # Blocks (with compression) using best_compression_block_size on this
  // least compressed tape.
  int64 best_compression_tape_size = 7;

  // Best multiple of best_compression_block_size found.
  int64 best_mult = 8;
  // "Chain factor" (steps_from_chain / steps_from_macro) at best_mult.
  float best_chain_factor = 9;
}

message BlockFinderResult {
  BlockFinderRequest parameters = 1;
  BlockFinderResponse result = 2;
}


message LinRecurFilterRequest {
  // Parameters
  int64 max_steps = 1;
  // Is start_step the min start time of LR?
  // Or just a time at which it had started by?
  bool find_min_start_step = 2;
}

message LinRecurFilterResponse {
  // Results
  // Did the filter classify this machine as LR?
  bool success = 3;
  // A step at which the machine is in Lin Recurrence.
  // If is_start_step_min=True, this is the smallest such step (i.e. the
  // step that Lin Recurrence began).
  int64 start_step = 4;
  // Period of LR cycle.
  int64 period = 5;
  // Tape offset distance from one cycle to the next
  // (+ means right, - means left, 0 means it repeats in place).
  int64 offset = 6;

  // Stats
  float elapsed_time_sec = 7;
}

message LinRecurFilterResult {
  LinRecurFilterRequest parameters = 1;
  LinRecurFilterResponse result = 2;
}


// The top level message for a TM. It contains:
//  * TM specification (ttable)
//  * Results for all filters that have been run
//  * Concluded "Statuses" for Halting, etc. conditions
message IORecord {
  TuringMachine tm = 1;

  // Status of this machine with respect to BB, BBB, etc. criteria.
  Status status = 2;

  // Raw parameters, results and stats from various filters.

  // We allow multiple SimulatorResults since we may have run it with different
  // parameters and get different results.
  repeated SimulatorResult simulator_results = 3;
  repeated BlockFinderResult block_finder_results = 4;

  LinRecurFilterResult lin_recur_filter_result = 5;
  // TODO: Add results for other filters (ReverseEngineer, CTL, ...)
}
