// Protobuf messages used for storing TM search results on disk.
//
// This is meant to replace the existing ad-hoc text format used by IO.py.
//
// It provides the main advantage of being extensible, adding a new field
// for new stats is trivial and backwards/forwards compatible. It also
// has the potential to be more efficient for data storage ...

syntax = "proto3";

package busy_beaver;


// A "potentially" big positive integer.
message BigInt {
  oneof big_int {
    // If the int is small enough, it is stored as a uint64.
    uint64 int = 1;
    // If it is too big (>= 2^64), serialize it as a text string.
    //
    // Note: If we have a lot of these, we could consider a more efficient
    // format, like byte-packing into a bytes object ... but I think it is
    // uncommon enough, that using this inefficient solution is fine.
    string str = 2;
  }
}

message TuringMachine {
  // TODO: We may want to encode this in a more efficient way.
  // Ex: a bytes with transitions bit-packed into 1 byte each? (~4x smaller).
  string ttable = 1;
}


// Statuses for various searches (BB, BBB, ...)
message HaltStatus {
  // Have we made a halting decision?
  bool is_decided = 1;
  // Does this machine halt? (Only meaningful if is_decided = True)
  bool is_halting = 2;

  BigInt halt_steps = 3;
  BigInt halt_score = 4;
}

message QuasihaltStatus {
  // Have we made a quasihalting decision?
  bool is_decided = 1;
  // Does this machine quasihalt? (Only meaningful if is_decided = True)
  bool is_quasihalting = 2;

  BigInt quasihalt_steps = 3;
  int64 quasihalt_state = 4;
}

message Status {
  HaltStatus halt_status = 1;
  QuasihaltStatus quasihalt_status = 2;
  // TODO: Add more, like lin_recur_info and blanking_info?
}


// Filter Results
message SimulatorRequest {
  // Parameters
  // TODO
}

message SimulatorResponse {
  // Results
  // Reason simulator finished (Halt, Inf, Over_Steps, Error, ...)
  string sim_condition = 1;

  // Stats
  float elapsed_time_sec = 2;

  int64 num_loops = 3;
  BigInt num_steps = 4;

  int64 num_rules_proven = 5;
  int64 num_proofs_failed = 6;
}

message SimulatorResult {
  SimulatorRequest parameters = 1;
  SimulatorResponse result = 2;
}


message LinRecurFilterRequest {
  // Parameters
  int64 max_steps = 1;
  // Is start_step the min start time of LR?
  // Or just a time at which it had started by?
  bool find_min_start_step = 2;
}

message LinRecurFilterResponse {
  // Results
  // Did the filter classify this machine as LR?
  bool success = 3;
  // A step at which the machine is in Lin Recurrence.
  // If is_start_step_min=True, this is the smallest such step (i.e. the
  // step that Lin Recurrence began).
  int64 start_step = 4;
  // Period of LR cycle.
  int64 period = 5;
  // Tape offset distance from one cycle to the next
  // (+ means right, - means left, 0 means it repeats in place).
  int64 offset = 6;

  // Stats
  float elapsed_time_sec = 7;
}

message LinRecurFilterResult {
  LinRecurFilterRequest parameters = 1;
  LinRecurFilterResponse result = 2;
}


// The top level message for a TM. It contains:
//  * TM specification (ttable)
//  * Results for all filters that have been run
//  * Concluded "Statuses" for Halting, etc. conditions
message IORecord {
  TuringMachine tm = 1;

  // Status of this machine with respect to BB, BBB, etc. criteria.
  Status status = 2;

  // Raw parameters, results and stats from various filters.

  // We allow multiple SimulatorResults since we may have run it with different
  // parameters and get different results.
  repeated SimulatorResult simulator_results = 3;

  LinRecurFilterResult lin_recur_filter_result = 4;
  // TODO: Add results for other filters (ReverseEngineer, CTL, ...)
}
