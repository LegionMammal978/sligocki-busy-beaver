"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Protobuf messages used for storing TM search results on disk.

This is meant to replace the existing ad-hoc text format used by IO.py.

It provides the main advantage of being extensible, adding a new field
for new stats is trivial and backwards/forwards compatible. It also
has the potential to be more efficient for data storage ...
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _InfReason:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _InfReasonEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_InfReason.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    INF_UNSPECIFIED: _InfReason.ValueType  # 0
    INF_MACRO_STEP: _InfReason.ValueType  # 1
    INF_CHAIN_STEP: _InfReason.ValueType  # 2
    INF_PROOF_SYSTEM: _InfReason.ValueType  # 3
    INF_REVERSE_ENGINEER: _InfReason.ValueType  # 4
    INF_LIN_RECUR: _InfReason.ValueType  # 5
    INF_CTL: _InfReason.ValueType  # 6
    INF_BACKTRACK: _InfReason.ValueType  # 7
    INF_CPS: _InfReason.ValueType  # 8

class InfReason(_InfReason, metaclass=_InfReasonEnumTypeWrapper): ...

INF_UNSPECIFIED: InfReason.ValueType  # 0
INF_MACRO_STEP: InfReason.ValueType  # 1
INF_CHAIN_STEP: InfReason.ValueType  # 2
INF_PROOF_SYSTEM: InfReason.ValueType  # 3
INF_REVERSE_ENGINEER: InfReason.ValueType  # 4
INF_LIN_RECUR: InfReason.ValueType  # 5
INF_CTL: InfReason.ValueType  # 6
INF_BACKTRACK: InfReason.ValueType  # 7
INF_CPS: InfReason.ValueType  # 8
global___InfReason = InfReason

@typing.final
class ExpTerm(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    BASE_FIELD_NUMBER: builtins.int
    COEF_FIELD_NUMBER: builtins.int
    EXPONENT_FIELD_NUMBER: builtins.int
    COEF_OLD_FIELD_NUMBER: builtins.int
    base: builtins.int
    coef_old: builtins.int
    """Deprecated"""
    @property
    def coef(self) -> global___BigInt:
        """coef may be larger than 2^63-1"""

    @property
    def exponent(self) -> global___BigInt:
        """Exponent may be plain integer or another ExpInt"""

    def __init__(
        self,
        *,
        base: builtins.int = ...,
        coef: global___BigInt | None = ...,
        exponent: global___BigInt | None = ...,
        coef_old: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["coef", b"coef", "exponent", b"exponent"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["base", b"base", "coef", b"coef", "coef_old", b"coef_old", "exponent", b"exponent"]) -> None: ...

global___ExpTerm = ExpTerm

@typing.final
class ExpInt(google.protobuf.message.Message):
    """protobuf version of type Exp_Int.ExpInt"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TERMS_FIELD_NUMBER: builtins.int
    CONST_FIELD_NUMBER: builtins.int
    DENOM_FIELD_NUMBER: builtins.int
    CONST_OLD_FIELD_NUMBER: builtins.int
    denom: builtins.int
    const_old: builtins.int
    """Deprecated"""
    @property
    def terms(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ExpTerm]: ...
    @property
    def const(self) -> global___BigInt:
        """const may be larger than 2^63-1"""

    def __init__(
        self,
        *,
        terms: collections.abc.Iterable[global___ExpTerm] | None = ...,
        const: global___BigInt | None = ...,
        denom: builtins.int = ...,
        const_old: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["const", b"const"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["const", b"const", "const_old", b"const_old", "denom", b"denom", "terms", b"terms"]) -> None: ...

global___ExpInt = ExpInt

@typing.final
class BigInt(google.protobuf.message.Message):
    """A "potentially" big positive integer."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    INT_FIELD_NUMBER: builtins.int
    HEX_STR_FIELD_NUMBER: builtins.int
    EXP_INT_FIELD_NUMBER: builtins.int
    EXP_INT_PICKLE_FIELD_NUMBER: builtins.int
    EXP_INT_STR_FIELD_NUMBER: builtins.int
    UINT_OLD_FIELD_NUMBER: builtins.int
    int: builtins.int
    """Small int: 0 to 2^63 - 1. Store directly."""
    hex_str: builtins.str
    """Medium int: 2^63 to ~2^1000 or so. Serialize in hex."""
    exp_int_pickle: builtins.bytes
    exp_int_str: builtins.str
    """DEPRECATED base 10 version: string str = 2;
    DEPRECATED
    """
    uint_old: builtins.int
    """DEPRECATED old format: ExpInt exp_int = 5;
    Deprecated
    """
    @property
    def exp_int(self) -> global___ExpInt:
        """Giant int: ~10^^15. Represented using a formula."""

    def __init__(
        self,
        *,
        int: builtins.int = ...,
        hex_str: builtins.str = ...,
        exp_int: global___ExpInt | None = ...,
        exp_int_pickle: builtins.bytes = ...,
        exp_int_str: builtins.str = ...,
        uint_old: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["big_int", b"big_int", "exp_int", b"exp_int", "exp_int_pickle", b"exp_int_pickle", "exp_int_str", b"exp_int_str", "hex_str", b"hex_str", "int", b"int", "uint_old", b"uint_old"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["big_int", b"big_int", "exp_int", b"exp_int", "exp_int_pickle", b"exp_int_pickle", "exp_int_str", b"exp_int_str", "hex_str", b"hex_str", "int", b"int", "uint_old", b"uint_old"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["big_int", b"big_int"]) -> typing.Literal["int", "hex_str", "exp_int", "exp_int_pickle", "exp_int_str", "uint_old"] | None: ...

global___BigInt = BigInt

@typing.final
class TMList(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NUM_STATES_FIELD_NUMBER: builtins.int
    NUM_SYMBOLS_FIELD_NUMBER: builtins.int
    TTABLE_LIST_FIELD_NUMBER: builtins.int
    num_states: builtins.int
    num_symbols: builtins.int
    @property
    def ttable_list(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]: ...
    def __init__(
        self,
        *,
        num_states: builtins.int = ...,
        num_symbols: builtins.int = ...,
        ttable_list: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["num_states", b"num_states", "num_symbols", b"num_symbols", "ttable_list", b"ttable_list"]) -> None: ...

global___TMList = TMList

@typing.final
class TuringMachine(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TTABLE_PACKED_FIELD_NUMBER: builtins.int
    TTABLE_LIST_FIELD_NUMBER: builtins.int
    TTABLE_STR_FIELD_NUMBER: builtins.int
    ALLOW_NO_HALT_FIELD_NUMBER: builtins.int
    ttable_packed: builtins.bytes
    """High density, bit-packed version of ttable.
    Each transition is represented by one byte from least significant to most:
      * 3 bits for (symbol + 1)  [symbol == -1 means undefined cell]
      * 3 bits for (state + 1)   [state == -1 means halt]
      * 1 bit for dir
      * 1 bit for is_newrow  [indicates where to add row breaks to matrix]
    """
    ttable_str: builtins.str
    """Deprecated"""
    allow_no_halt: builtins.bool
    """Enumeration options"""
    @property
    def ttable_list(self) -> global___TMList:
        """Simple low density format. 12B / transition.
        Almost unbounded (up to 2^31 - 1 states and symbols).
        """

    def __init__(
        self,
        *,
        ttable_packed: builtins.bytes = ...,
        ttable_list: global___TMList | None = ...,
        ttable_str: builtins.str = ...,
        allow_no_halt: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["ttable", b"ttable", "ttable_list", b"ttable_list", "ttable_packed", b"ttable_packed", "ttable_str", b"ttable_str"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["allow_no_halt", b"allow_no_halt", "ttable", b"ttable", "ttable_list", b"ttable_list", "ttable_packed", b"ttable_packed", "ttable_str", b"ttable_str"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["ttable", b"ttable"]) -> typing.Literal["ttable_packed", "ttable_list", "ttable_str"] | None: ...

global___TuringMachine = TuringMachine

@typing.final
class HaltStatus(google.protobuf.message.Message):
    """Statuses for various searches (BB, BBB, ...)"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    IS_DECIDED_FIELD_NUMBER: builtins.int
    IS_HALTING_FIELD_NUMBER: builtins.int
    HALT_STEPS_FIELD_NUMBER: builtins.int
    HALT_SCORE_FIELD_NUMBER: builtins.int
    FROM_STATE_FIELD_NUMBER: builtins.int
    FROM_SYMBOL_FIELD_NUMBER: builtins.int
    INF_REASON_FIELD_NUMBER: builtins.int
    is_decided: builtins.bool
    """Have we made a halting decision?"""
    is_halting: builtins.bool
    """Does this machine halt? (Only meaningful if is_decided = True)"""
    from_state: builtins.int
    """Which transition led to halt (important for enumerating in TNF)."""
    from_symbol: builtins.int
    inf_reason: global___InfReason.ValueType
    """Only meaningful if is_halting = False."""
    @property
    def halt_steps(self) -> global___BigInt:
        """Only meaningful if is_halting = True."""

    @property
    def halt_score(self) -> global___BigInt: ...
    def __init__(
        self,
        *,
        is_decided: builtins.bool = ...,
        is_halting: builtins.bool = ...,
        halt_steps: global___BigInt | None = ...,
        halt_score: global___BigInt | None = ...,
        from_state: builtins.int = ...,
        from_symbol: builtins.int = ...,
        inf_reason: global___InfReason.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["halt_score", b"halt_score", "halt_steps", b"halt_steps"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["from_state", b"from_state", "from_symbol", b"from_symbol", "halt_score", b"halt_score", "halt_steps", b"halt_steps", "inf_reason", b"inf_reason", "is_decided", b"is_decided", "is_halting", b"is_halting"]) -> None: ...

global___HaltStatus = HaltStatus

@typing.final
class QuasihaltStatus(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    IS_DECIDED_FIELD_NUMBER: builtins.int
    IS_QUASIHALTING_FIELD_NUMBER: builtins.int
    QUASIHALT_STEPS_FIELD_NUMBER: builtins.int
    QUASIHALT_STATE_FIELD_NUMBER: builtins.int
    is_decided: builtins.bool
    """Have we made a quasihalting decision?"""
    is_quasihalting: builtins.bool
    """Does this machine quasihalt? (Only meaningful if is_decided = True)"""
    quasihalt_state: builtins.int
    @property
    def quasihalt_steps(self) -> global___BigInt: ...
    def __init__(
        self,
        *,
        is_decided: builtins.bool = ...,
        is_quasihalting: builtins.bool = ...,
        quasihalt_steps: global___BigInt | None = ...,
        quasihalt_state: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["quasihalt_steps", b"quasihalt_steps"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["is_decided", b"is_decided", "is_quasihalting", b"is_quasihalting", "quasihalt_state", b"quasihalt_state", "quasihalt_steps", b"quasihalt_steps"]) -> None: ...

global___QuasihaltStatus = QuasihaltStatus

@typing.final
class BBStatus(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    HALT_STATUS_FIELD_NUMBER: builtins.int
    QUASIHALT_STATUS_FIELD_NUMBER: builtins.int
    @property
    def halt_status(self) -> global___HaltStatus: ...
    @property
    def quasihalt_status(self) -> global___QuasihaltStatus:
        """TODO: Add more, like lin_recur_status and blanking_status?"""

    def __init__(
        self,
        *,
        halt_status: global___HaltStatus | None = ...,
        quasihalt_status: global___QuasihaltStatus | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["halt_status", b"halt_status", "quasihalt_status", b"quasihalt_status"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["halt_status", b"halt_status", "quasihalt_status", b"quasihalt_status"]) -> None: ...

global___BBStatus = BBStatus

@typing.final
class SimulatorParams(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    BLOCK_SIZE_FIELD_NUMBER: builtins.int
    HAS_BLOCKSYMBOL_MACRO_FIELD_NUMBER: builtins.int
    MAX_LOOPS_FIELD_NUMBER: builtins.int
    MAX_TIME_SEC_FIELD_NUMBER: builtins.int
    MAX_TAPE_BLOCKS_FIELD_NUMBER: builtins.int
    USE_PROVER_FIELD_NUMBER: builtins.int
    ONLY_LOG_CONFIGS_AT_EDGE_FIELD_NUMBER: builtins.int
    USE_LIMITED_RULES_FIELD_NUMBER: builtins.int
    USE_RECURSIVE_RULES_FIELD_NUMBER: builtins.int
    block_size: builtins.int
    """Macro machine configuration."""
    has_blocksymbol_macro: builtins.bool
    max_loops: builtins.int
    """Maximum number of simulator "loops" to run for."""
    max_time_sec: builtins.float
    """Maximum wall time to run the simulator for."""
    max_tape_blocks: builtins.int
    """Maximum size of compressed tape before we give up."""
    use_prover: builtins.bool
    """Prover Params"""
    only_log_configs_at_edge: builtins.bool
    """Instead of logging stripped configuration at all steps in order to try and
    prove rules, only do it when the TM is at the edge of the tape. Any rule
    that expands the written part of the tape will (by definition) have to go
    to the edge, so this "shouldn't" hurt much.
    """
    use_limited_rules: builtins.bool
    use_recursive_rules: builtins.bool
    def __init__(
        self,
        *,
        block_size: builtins.int = ...,
        has_blocksymbol_macro: builtins.bool = ...,
        max_loops: builtins.int = ...,
        max_time_sec: builtins.float = ...,
        max_tape_blocks: builtins.int = ...,
        use_prover: builtins.bool = ...,
        only_log_configs_at_edge: builtins.bool = ...,
        use_limited_rules: builtins.bool = ...,
        use_recursive_rules: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["block_size", b"block_size", "has_blocksymbol_macro", b"has_blocksymbol_macro", "max_loops", b"max_loops", "max_tape_blocks", b"max_tape_blocks", "max_time_sec", b"max_time_sec", "only_log_configs_at_edge", b"only_log_configs_at_edge", "use_limited_rules", b"use_limited_rules", "use_prover", b"use_prover", "use_recursive_rules", b"use_recursive_rules"]) -> None: ...

global___SimulatorParams = SimulatorParams

@typing.final
class HaltInfo(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    IS_HALTING_FIELD_NUMBER: builtins.int
    is_halting: builtins.bool
    def __init__(
        self,
        *,
        is_halting: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["is_halting", b"is_halting"]) -> None: ...

global___HaltInfo = HaltInfo

@typing.final
class InfMacroRepeatInfo(google.protobuf.message.Message):
    """TM repeats infinitely in place while evaluating a macro transition."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MACRO_SYMBOL_FIELD_NUMBER: builtins.int
    MACRO_STATE_FIELD_NUMBER: builtins.int
    MACRO_DIR_IS_RIGHT_FIELD_NUMBER: builtins.int
    macro_symbol: builtins.str
    """The macro symbol and macro state immediately preceding the repeat."""
    macro_state: builtins.str
    macro_dir_is_right: builtins.bool
    def __init__(
        self,
        *,
        macro_symbol: builtins.str = ...,
        macro_state: builtins.str = ...,
        macro_dir_is_right: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["macro_dir_is_right", b"macro_dir_is_right", "macro_state", b"macro_state", "macro_symbol", b"macro_symbol"]) -> None: ...

global___InfMacroRepeatInfo = InfMacroRepeatInfo

@typing.final
class InfChainMoveInfo(google.protobuf.message.Message):
    """Simulator attempted to apply a chain move to the infinite block of 0s
    thus demonstrating that this TM will move infinitely in one state across
    those 0s (Chain Recurrence). It has "Spun out".
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MACRO_STATE_FIELD_NUMBER: builtins.int
    DIR_IS_RIGHT_FIELD_NUMBER: builtins.int
    macro_state: builtins.str
    dir_is_right: builtins.bool
    """Is this Chain Recurrence to the right?"""
    def __init__(
        self,
        *,
        macro_state: builtins.str = ...,
        dir_is_right: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["dir_is_right", b"dir_is_right", "macro_state", b"macro_state"]) -> None: ...

global___InfChainMoveInfo = InfChainMoveInfo

@typing.final
class InfProofSystemInfo(google.protobuf.message.Message):
    """Simulator proved a PA-CTR rule that has all positive exponent changes, thus
    it will apply forever.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RULE_FIELD_NUMBER: builtins.int
    rule: builtins.str
    """Human readable summary of the rule itself."""
    def __init__(
        self,
        *,
        rule: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["rule", b"rule"]) -> None: ...

global___InfProofSystemInfo = InfProofSystemInfo

@typing.final
class InfiniteInfo(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MACRO_REPEAT_FIELD_NUMBER: builtins.int
    CHAIN_MOVE_FIELD_NUMBER: builtins.int
    PROOF_SYSTEM_FIELD_NUMBER: builtins.int
    @property
    def macro_repeat(self) -> global___InfMacroRepeatInfo: ...
    @property
    def chain_move(self) -> global___InfChainMoveInfo: ...
    @property
    def proof_system(self) -> global___InfProofSystemInfo:
        """TODO: ..."""

    def __init__(
        self,
        *,
        macro_repeat: global___InfMacroRepeatInfo | None = ...,
        chain_move: global___InfChainMoveInfo | None = ...,
        proof_system: global___InfProofSystemInfo | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["chain_move", b"chain_move", "macro_repeat", b"macro_repeat", "proof_system", b"proof_system", "reason", b"reason"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["chain_move", b"chain_move", "macro_repeat", b"macro_repeat", "proof_system", b"proof_system", "reason", b"reason"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["reason", b"reason"]) -> typing.Literal["macro_repeat", "chain_move", "proof_system"] | None: ...

global___InfiniteInfo = InfiniteInfo

@typing.final
class OverLoopsInfo(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NUM_LOOPS_FIELD_NUMBER: builtins.int
    num_loops: builtins.int
    def __init__(
        self,
        *,
        num_loops: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["num_loops", b"num_loops"]) -> None: ...

global___OverLoopsInfo = OverLoopsInfo

@typing.final
class OverTapeInfo(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    COMPRESSED_TAPE_SIZE_FIELD_NUMBER: builtins.int
    compressed_tape_size: builtins.int
    def __init__(
        self,
        *,
        compressed_tape_size: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["compressed_tape_size", b"compressed_tape_size"]) -> None: ...

global___OverTapeInfo = OverTapeInfo

@typing.final
class OverTimeInfo(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ELAPSED_TIME_SEC_FIELD_NUMBER: builtins.int
    elapsed_time_sec: builtins.float
    def __init__(
        self,
        *,
        elapsed_time_sec: builtins.float = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["elapsed_time_sec", b"elapsed_time_sec"]) -> None: ...

global___OverTimeInfo = OverTimeInfo

@typing.final
class OverStepsInMacroInfo(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MACRO_SYMBOL_FIELD_NUMBER: builtins.int
    MACRO_STATE_FIELD_NUMBER: builtins.int
    MACRO_DIR_IS_RIGHT_FIELD_NUMBER: builtins.int
    macro_symbol: builtins.str
    """The macro symbol and macro state which took to long to simulate."""
    macro_state: builtins.str
    macro_dir_is_right: builtins.bool
    def __init__(
        self,
        *,
        macro_symbol: builtins.str = ...,
        macro_state: builtins.str = ...,
        macro_dir_is_right: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["macro_dir_is_right", b"macro_dir_is_right", "macro_state", b"macro_state", "macro_symbol", b"macro_symbol"]) -> None: ...

global___OverStepsInMacroInfo = OverStepsInMacroInfo

@typing.final
class UnknownInfo(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    OVER_LOOPS_FIELD_NUMBER: builtins.int
    OVER_TAPE_FIELD_NUMBER: builtins.int
    OVER_TIME_FIELD_NUMBER: builtins.int
    OVER_STEPS_IN_MACRO_FIELD_NUMBER: builtins.int
    THREW_EXCEPTION_FIELD_NUMBER: builtins.int
    threw_exception: builtins.bool
    @property
    def over_loops(self) -> global___OverLoopsInfo: ...
    @property
    def over_tape(self) -> global___OverTapeInfo: ...
    @property
    def over_time(self) -> global___OverTimeInfo: ...
    @property
    def over_steps_in_macro(self) -> global___OverStepsInMacroInfo: ...
    def __init__(
        self,
        *,
        over_loops: global___OverLoopsInfo | None = ...,
        over_tape: global___OverTapeInfo | None = ...,
        over_time: global___OverTimeInfo | None = ...,
        over_steps_in_macro: global___OverStepsInMacroInfo | None = ...,
        threw_exception: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["over_loops", b"over_loops", "over_steps_in_macro", b"over_steps_in_macro", "over_tape", b"over_tape", "over_time", b"over_time", "reason", b"reason", "threw_exception", b"threw_exception"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["over_loops", b"over_loops", "over_steps_in_macro", b"over_steps_in_macro", "over_tape", b"over_tape", "over_time", b"over_time", "reason", b"reason", "threw_exception", b"threw_exception"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["reason", b"reason"]) -> typing.Literal["over_loops", "over_tape", "over_time", "over_steps_in_macro", "threw_exception"] | None: ...

global___UnknownInfo = UnknownInfo

@typing.final
class SimulatorResult(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    HALT_INFO_FIELD_NUMBER: builtins.int
    INFINITE_INFO_FIELD_NUMBER: builtins.int
    UNKNOWN_INFO_FIELD_NUMBER: builtins.int
    ELAPSED_TIME_US_FIELD_NUMBER: builtins.int
    NUM_LOOPS_FIELD_NUMBER: builtins.int
    NUM_MACRO_MOVES_FIELD_NUMBER: builtins.int
    NUM_CHAIN_MOVES_FIELD_NUMBER: builtins.int
    NUM_RULE_MOVES_FIELD_NUMBER: builtins.int
    LOG10_NUM_STEPS_FIELD_NUMBER: builtins.int
    NUM_RULES_PROVEN_FIELD_NUMBER: builtins.int
    NUM_META_DIFF_RULES_PROVEN_FIELD_NUMBER: builtins.int
    NUM_LINEAR_RULES_PROVEN_FIELD_NUMBER: builtins.int
    NUM_FINITE_LINEAR_RULES_PROVEN_FIELD_NUMBER: builtins.int
    NUM_EXPONENTIAL_RULES_PROVEN_FIELD_NUMBER: builtins.int
    NUM_GEN_RULES_PROVEN_FIELD_NUMBER: builtins.int
    NUM_COLLATZ_RULES_FIELD_NUMBER: builtins.int
    NUM_PROOFS_FAILED_FIELD_NUMBER: builtins.int
    elapsed_time_us: builtins.int
    """Stats"""
    num_loops: builtins.int
    """Number of simulator steps (or loops). One simulator step is either a
    basic Macro Machine step, a Chain Step or a Rule Step.
    """
    num_macro_moves: builtins.int
    num_chain_moves: builtins.int
    num_rule_moves: builtins.int
    log10_num_steps: builtins.int
    """Number of base TM steps that this TM was simulated up to. We don't need
    to know the precise num_steps, just want ballpark (order of magnitude).
    """
    num_rules_proven: builtins.int
    num_meta_diff_rules_proven: builtins.int
    num_linear_rules_proven: builtins.int
    num_finite_linear_rules_proven: builtins.int
    """Only count non-infinite rules (rules with at least one exponent reducing)."""
    num_exponential_rules_proven: builtins.int
    num_gen_rules_proven: builtins.int
    num_collatz_rules: builtins.int
    """Note: These are rules from above that have the property that one of the
    exponents decreases by more than 1.
    """
    num_proofs_failed: builtins.int
    @property
    def halt_info(self) -> global___HaltInfo: ...
    @property
    def infinite_info(self) -> global___InfiniteInfo: ...
    @property
    def unknown_info(self) -> global___UnknownInfo:
        """We could not decide if this machine halted or will never halt."""

    def __init__(
        self,
        *,
        halt_info: global___HaltInfo | None = ...,
        infinite_info: global___InfiniteInfo | None = ...,
        unknown_info: global___UnknownInfo | None = ...,
        elapsed_time_us: builtins.int = ...,
        num_loops: builtins.int = ...,
        num_macro_moves: builtins.int = ...,
        num_chain_moves: builtins.int = ...,
        num_rule_moves: builtins.int = ...,
        log10_num_steps: builtins.int = ...,
        num_rules_proven: builtins.int = ...,
        num_meta_diff_rules_proven: builtins.int = ...,
        num_linear_rules_proven: builtins.int = ...,
        num_finite_linear_rules_proven: builtins.int = ...,
        num_exponential_rules_proven: builtins.int = ...,
        num_gen_rules_proven: builtins.int = ...,
        num_collatz_rules: builtins.int = ...,
        num_proofs_failed: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["exit_condition", b"exit_condition", "halt_info", b"halt_info", "infinite_info", b"infinite_info", "unknown_info", b"unknown_info"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["elapsed_time_us", b"elapsed_time_us", "exit_condition", b"exit_condition", "halt_info", b"halt_info", "infinite_info", b"infinite_info", "log10_num_steps", b"log10_num_steps", "num_chain_moves", b"num_chain_moves", "num_collatz_rules", b"num_collatz_rules", "num_exponential_rules_proven", b"num_exponential_rules_proven", "num_finite_linear_rules_proven", b"num_finite_linear_rules_proven", "num_gen_rules_proven", b"num_gen_rules_proven", "num_linear_rules_proven", b"num_linear_rules_proven", "num_loops", b"num_loops", "num_macro_moves", b"num_macro_moves", "num_meta_diff_rules_proven", b"num_meta_diff_rules_proven", "num_proofs_failed", b"num_proofs_failed", "num_rule_moves", b"num_rule_moves", "num_rules_proven", b"num_rules_proven", "unknown_info", b"unknown_info"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["exit_condition", b"exit_condition"]) -> typing.Literal["halt_info", "infinite_info", "unknown_info"] | None: ...

global___SimulatorResult = SimulatorResult

@typing.final
class SimulatorInfo(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARAMETERS_FIELD_NUMBER: builtins.int
    RESULT_FIELD_NUMBER: builtins.int
    @property
    def parameters(self) -> global___SimulatorParams: ...
    @property
    def result(self) -> global___SimulatorResult: ...
    def __init__(
        self,
        *,
        parameters: global___SimulatorParams | None = ...,
        result: global___SimulatorResult | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["parameters", b"parameters", "result", b"result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["parameters", b"parameters", "result", b"result"]) -> None: ...

global___SimulatorInfo = SimulatorInfo

@typing.final
class BlockFinderParams(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    COMPRESSION_SEARCH_LOOPS_FIELD_NUMBER: builtins.int
    MULT_SIM_LOOPS_FIELD_NUMBER: builtins.int
    MAX_BLOCK_MULT_FIELD_NUMBER: builtins.int
    MAX_BLOCK_SIZE_FIELD_NUMBER: builtins.int
    BLOCK_MULT_FIELD_NUMBER: builtins.int
    compression_search_loops: builtins.int
    """# loops to run Sim searching for least-compressed tape."""
    mult_sim_loops: builtins.int
    """# loops to run sim for each multiple of optimal compression size."""
    max_block_mult: builtins.int
    """While searching for optimal multiple: How far should we look beyond
    current best mult?
    """
    max_block_size: builtins.int
    block_mult: builtins.int
    """If non-zero, fixed block mult."""
    def __init__(
        self,
        *,
        compression_search_loops: builtins.int = ...,
        mult_sim_loops: builtins.int = ...,
        max_block_mult: builtins.int = ...,
        max_block_size: builtins.int = ...,
        block_mult: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["block_mult", b"block_mult", "compression_search_loops", b"compression_search_loops", "max_block_mult", b"max_block_mult", "max_block_size", b"max_block_size", "mult_sim_loops", b"mult_sim_loops"]) -> None: ...

global___BlockFinderParams = BlockFinderParams

@typing.final
class BlockFinderResult(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    BEST_BLOCK_SIZE_FIELD_NUMBER: builtins.int
    ELAPSED_TIME_US_FIELD_NUMBER: builtins.int
    LEAST_COMPRESSED_LOOP_FIELD_NUMBER: builtins.int
    LEAST_COMPRESSED_TAPE_SIZE_CHAIN_FIELD_NUMBER: builtins.int
    LEAST_COMPRESSED_TAPE_SIZE_RAW_FIELD_NUMBER: builtins.int
    BEST_COMPRESSION_BLOCK_SIZE_FIELD_NUMBER: builtins.int
    BEST_COMPRESSION_TAPE_SIZE_FIELD_NUMBER: builtins.int
    BEST_MULT_FIELD_NUMBER: builtins.int
    BEST_CHAIN_FACTOR_FIELD_NUMBER: builtins.int
    best_block_size: builtins.int
    """Results
    Overall heuristically decided best block size.
    """
    elapsed_time_us: builtins.int
    """Stats"""
    least_compressed_loop: builtins.int
    """Chain Sim loop (with block size 1) where compressed tape was largest
    (least effectively compressed).
    """
    least_compressed_tape_size_chain: builtins.int
    """# Blocks (with compression) on this least compressed tape."""
    least_compressed_tape_size_raw: builtins.int
    """Total # symbols (no compression) on this least compressed tape."""
    best_compression_block_size: builtins.int
    """Best block size for compression on this least compressed tape."""
    best_compression_tape_size: builtins.int
    """# Blocks (with compression) using best_compression_block_size on this
    least compressed tape.
    """
    best_mult: builtins.int
    """Best multiple of best_compression_block_size found."""
    best_chain_factor: builtins.float
    """"Chain factor" (steps_from_chain / steps_from_macro) at best_mult."""
    def __init__(
        self,
        *,
        best_block_size: builtins.int = ...,
        elapsed_time_us: builtins.int = ...,
        least_compressed_loop: builtins.int = ...,
        least_compressed_tape_size_chain: builtins.int = ...,
        least_compressed_tape_size_raw: builtins.int = ...,
        best_compression_block_size: builtins.int = ...,
        best_compression_tape_size: builtins.int = ...,
        best_mult: builtins.int = ...,
        best_chain_factor: builtins.float = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["best_block_size", b"best_block_size", "best_chain_factor", b"best_chain_factor", "best_compression_block_size", b"best_compression_block_size", "best_compression_tape_size", b"best_compression_tape_size", "best_mult", b"best_mult", "elapsed_time_us", b"elapsed_time_us", "least_compressed_loop", b"least_compressed_loop", "least_compressed_tape_size_chain", b"least_compressed_tape_size_chain", "least_compressed_tape_size_raw", b"least_compressed_tape_size_raw"]) -> None: ...

global___BlockFinderResult = BlockFinderResult

@typing.final
class BlockFinderInfo(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARAMETERS_FIELD_NUMBER: builtins.int
    RESULT_FIELD_NUMBER: builtins.int
    @property
    def parameters(self) -> global___BlockFinderParams: ...
    @property
    def result(self) -> global___BlockFinderResult: ...
    def __init__(
        self,
        *,
        parameters: global___BlockFinderParams | None = ...,
        result: global___BlockFinderResult | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["parameters", b"parameters", "result", b"result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["parameters", b"parameters", "result", b"result"]) -> None: ...

global___BlockFinderInfo = BlockFinderInfo

@typing.final
class FilterInfo(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TESTED_FIELD_NUMBER: builtins.int
    SUCCESS_FIELD_NUMBER: builtins.int
    ELAPSED_TIME_US_FIELD_NUMBER: builtins.int
    tested: builtins.bool
    success: builtins.bool
    elapsed_time_us: builtins.int
    """Stats"""
    def __init__(
        self,
        *,
        tested: builtins.bool = ...,
        success: builtins.bool = ...,
        elapsed_time_us: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["elapsed_time_us", b"elapsed_time_us", "success", b"success", "tested", b"tested"]) -> None: ...

global___FilterInfo = FilterInfo

@typing.final
class LinRecurFilterParams(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MAX_STEPS_FIELD_NUMBER: builtins.int
    FIND_MIN_START_STEP_FIELD_NUMBER: builtins.int
    max_steps: builtins.int
    """Parameters"""
    find_min_start_step: builtins.bool
    """Is start_step the min start time of LR?
    Or just a time at which it had started by?
    """
    def __init__(
        self,
        *,
        max_steps: builtins.int = ...,
        find_min_start_step: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["find_min_start_step", b"find_min_start_step", "max_steps", b"max_steps"]) -> None: ...

global___LinRecurFilterParams = LinRecurFilterParams

@typing.final
class LinRecurFilterResult(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SUCCESS_FIELD_NUMBER: builtins.int
    START_STEP_FIELD_NUMBER: builtins.int
    PERIOD_FIELD_NUMBER: builtins.int
    OFFSET_FIELD_NUMBER: builtins.int
    ELAPSED_TIME_US_FIELD_NUMBER: builtins.int
    success: builtins.bool
    """Results
    Did the filter classify this machine as LR?
    """
    start_step: builtins.int
    """A step at which the machine is in Lin Recurrence.
    If is_start_step_min=True, this is the smallest such step (i.e. the
    step that Lin Recurrence began).
    """
    period: builtins.int
    """Period of LR cycle."""
    offset: builtins.int
    """Tape offset distance from one cycle to the next
    (+ means right, - means left, 0 means it repeats in place).
    """
    elapsed_time_us: builtins.int
    """Stats"""
    def __init__(
        self,
        *,
        success: builtins.bool = ...,
        start_step: builtins.int = ...,
        period: builtins.int = ...,
        offset: builtins.int = ...,
        elapsed_time_us: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["elapsed_time_us", b"elapsed_time_us", "offset", b"offset", "period", b"period", "start_step", b"start_step", "success", b"success"]) -> None: ...

global___LinRecurFilterResult = LinRecurFilterResult

@typing.final
class LinRecurFilterInfo(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARAMETERS_FIELD_NUMBER: builtins.int
    RESULT_FIELD_NUMBER: builtins.int
    @property
    def parameters(self) -> global___LinRecurFilterParams: ...
    @property
    def result(self) -> global___LinRecurFilterResult: ...
    def __init__(
        self,
        *,
        parameters: global___LinRecurFilterParams | None = ...,
        result: global___LinRecurFilterResult | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["parameters", b"parameters", "result", b"result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["parameters", b"parameters", "result", b"result"]) -> None: ...

global___LinRecurFilterInfo = LinRecurFilterInfo

@typing.final
class CTLParams(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    BLOCK_SIZE_FIELD_NUMBER: builtins.int
    OFFSET_FIELD_NUMBER: builtins.int
    CUTOFF_FIELD_NUMBER: builtins.int
    block_size: builtins.int
    """Parameters"""
    offset: builtins.int
    cutoff: builtins.int
    def __init__(
        self,
        *,
        block_size: builtins.int = ...,
        offset: builtins.int = ...,
        cutoff: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["block_size", b"block_size", "cutoff", b"cutoff", "offset", b"offset"]) -> None: ...

global___CTLParams = CTLParams

@typing.final
class CTLResult(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SUCCESS_FIELD_NUMBER: builtins.int
    NUM_ITERS_FIELD_NUMBER: builtins.int
    ELAPSED_TIME_US_FIELD_NUMBER: builtins.int
    success: builtins.bool
    """Results"""
    num_iters: builtins.int
    """Stats"""
    elapsed_time_us: builtins.int
    def __init__(
        self,
        *,
        success: builtins.bool = ...,
        num_iters: builtins.int = ...,
        elapsed_time_us: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["elapsed_time_us", b"elapsed_time_us", "num_iters", b"num_iters", "success", b"success"]) -> None: ...

global___CTLResult = CTLResult

@typing.final
class CTLInfo(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARAMETERS_FIELD_NUMBER: builtins.int
    RESULT_FIELD_NUMBER: builtins.int
    @property
    def parameters(self) -> global___CTLParams: ...
    @property
    def result(self) -> global___CTLResult: ...
    def __init__(
        self,
        *,
        parameters: global___CTLParams | None = ...,
        result: global___CTLResult | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["parameters", b"parameters", "result", b"result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["parameters", b"parameters", "result", b"result"]) -> None: ...

global___CTLInfo = CTLInfo

@typing.final
class CTLFilterInfo(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CTL_AS_FIELD_NUMBER: builtins.int
    CTL_AS_B_FIELD_NUMBER: builtins.int
    CTL_A_BS_FIELD_NUMBER: builtins.int
    CTL_AS_B_C_FIELD_NUMBER: builtins.int
    @property
    def ctl_as(self) -> global___CTLInfo:
        """CTL1: CTL_A*"""

    @property
    def ctl_as_b(self) -> global___CTLInfo:
        """CTL2: CTL_A*_B"""

    @property
    def ctl_a_bs(self) -> global___CTLInfo:
        """CTL3: CTL_A_B*"""

    @property
    def ctl_as_b_c(self) -> global___CTLInfo:
        """CTL4: CTL_A*_B_C"""

    def __init__(
        self,
        *,
        ctl_as: global___CTLInfo | None = ...,
        ctl_as_b: global___CTLInfo | None = ...,
        ctl_a_bs: global___CTLInfo | None = ...,
        ctl_as_b_c: global___CTLInfo | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["ctl_a_bs", b"ctl_a_bs", "ctl_as", b"ctl_as", "ctl_as_b", b"ctl_as_b", "ctl_as_b_c", b"ctl_as_b_c"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["ctl_a_bs", b"ctl_a_bs", "ctl_as", b"ctl_as", "ctl_as_b", b"ctl_as_b", "ctl_as_b_c", b"ctl_as_b_c"]) -> None: ...

global___CTLFilterInfo = CTLFilterInfo

@typing.final
class BacktrackFilterParams(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NUM_STEPS_FIELD_NUMBER: builtins.int
    MAX_WIDTH_FIELD_NUMBER: builtins.int
    num_steps: builtins.int
    """Maximum depth of BFS search tree to try before giving up."""
    max_width: builtins.int
    """Maximum width of BFS search tree to try before giving up."""
    def __init__(
        self,
        *,
        num_steps: builtins.int = ...,
        max_width: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["max_width", b"max_width", "num_steps", b"num_steps"]) -> None: ...

global___BacktrackFilterParams = BacktrackFilterParams

@typing.final
class BacktrackFilterResult(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SUCCESS_FIELD_NUMBER: builtins.int
    MAX_STEPS_FIELD_NUMBER: builtins.int
    MAX_WIDTH_FIELD_NUMBER: builtins.int
    NUM_NODES_FIELD_NUMBER: builtins.int
    ELAPSED_TIME_US_FIELD_NUMBER: builtins.int
    success: builtins.bool
    max_steps: builtins.int
    """Maximum depth of BFS search tree reached."""
    max_width: builtins.int
    """Maximum width of BFS search tree reached."""
    num_nodes: builtins.int
    """Number of nodes in BFS search tree."""
    elapsed_time_us: builtins.int
    """Stats"""
    def __init__(
        self,
        *,
        success: builtins.bool = ...,
        max_steps: builtins.int = ...,
        max_width: builtins.int = ...,
        num_nodes: builtins.int = ...,
        elapsed_time_us: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["elapsed_time_us", b"elapsed_time_us", "max_steps", b"max_steps", "max_width", b"max_width", "num_nodes", b"num_nodes", "success", b"success"]) -> None: ...

global___BacktrackFilterResult = BacktrackFilterResult

@typing.final
class BacktrackFilterInfo(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARAMETERS_FIELD_NUMBER: builtins.int
    RESULT_FIELD_NUMBER: builtins.int
    @property
    def parameters(self) -> global___BacktrackFilterParams: ...
    @property
    def result(self) -> global___BacktrackFilterResult: ...
    def __init__(
        self,
        *,
        parameters: global___BacktrackFilterParams | None = ...,
        result: global___BacktrackFilterResult | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["parameters", b"parameters", "result", b"result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["parameters", b"parameters", "result", b"result"]) -> None: ...

global___BacktrackFilterInfo = BacktrackFilterInfo

@typing.final
class CPSFilterParams(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MIN_BLOCK_SIZE_FIELD_NUMBER: builtins.int
    MAX_BLOCK_SIZE_FIELD_NUMBER: builtins.int
    SEARCH_ALL_WINDOWS_FIELD_NUMBER: builtins.int
    LRU_HISTORY_FIELD_NUMBER: builtins.int
    FIXED_HISTORY_FIELD_NUMBER: builtins.int
    MAX_STEPS_FIELD_NUMBER: builtins.int
    MAX_ITERS_FIELD_NUMBER: builtins.int
    MAX_CONFIGS_FIELD_NUMBER: builtins.int
    MAX_EDGES_FIELD_NUMBER: builtins.int
    min_block_size: builtins.int
    """Parameters"""
    max_block_size: builtins.int
    search_all_windows: builtins.bool
    lru_history: builtins.bool
    fixed_history: builtins.int
    max_steps: builtins.int
    max_iters: builtins.int
    max_configs: builtins.int
    max_edges: builtins.int
    def __init__(
        self,
        *,
        min_block_size: builtins.int = ...,
        max_block_size: builtins.int = ...,
        search_all_windows: builtins.bool = ...,
        lru_history: builtins.bool = ...,
        fixed_history: builtins.int = ...,
        max_steps: builtins.int = ...,
        max_iters: builtins.int = ...,
        max_configs: builtins.int = ...,
        max_edges: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["fixed_history", b"fixed_history", "lru_history", b"lru_history", "max_block_size", b"max_block_size", "max_configs", b"max_configs", "max_edges", b"max_edges", "max_iters", b"max_iters", "max_steps", b"max_steps", "min_block_size", b"min_block_size", "search_all_windows", b"search_all_windows"]) -> None: ...

global___CPSFilterParams = CPSFilterParams

@typing.final
class CPSFilterResult(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SUCCESS_FIELD_NUMBER: builtins.int
    BLOCK_SIZE_FIELD_NUMBER: builtins.int
    WINDOW_SIZE_FIELD_NUMBER: builtins.int
    NUM_STEPS_FIELD_NUMBER: builtins.int
    NUM_CONFIGS_FIELD_NUMBER: builtins.int
    NUM_EDGES_FIELD_NUMBER: builtins.int
    NUM_ITERS_FIELD_NUMBER: builtins.int
    FOUND_INF_LOOP_FIELD_NUMBER: builtins.int
    ELAPSED_TIME_US_FIELD_NUMBER: builtins.int
    success: builtins.bool
    """Results"""
    block_size: builtins.int
    """Which parameters worked?"""
    window_size: builtins.int
    """TODO: Implement with offset?"""
    num_steps: builtins.int
    """Stats"""
    num_configs: builtins.int
    num_edges: builtins.int
    num_iters: builtins.int
    found_inf_loop: builtins.bool
    elapsed_time_us: builtins.int
    def __init__(
        self,
        *,
        success: builtins.bool = ...,
        block_size: builtins.int = ...,
        window_size: builtins.int = ...,
        num_steps: builtins.int = ...,
        num_configs: builtins.int = ...,
        num_edges: builtins.int = ...,
        num_iters: builtins.int = ...,
        found_inf_loop: builtins.bool = ...,
        elapsed_time_us: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["block_size", b"block_size", "elapsed_time_us", b"elapsed_time_us", "found_inf_loop", b"found_inf_loop", "num_configs", b"num_configs", "num_edges", b"num_edges", "num_iters", b"num_iters", "num_steps", b"num_steps", "success", b"success", "window_size", b"window_size"]) -> None: ...

global___CPSFilterResult = CPSFilterResult

@typing.final
class CPSFilterInfo(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARAMETERS_FIELD_NUMBER: builtins.int
    RESULT_FIELD_NUMBER: builtins.int
    @property
    def parameters(self) -> global___CPSFilterParams: ...
    @property
    def result(self) -> global___CPSFilterResult: ...
    def __init__(
        self,
        *,
        parameters: global___CPSFilterParams | None = ...,
        result: global___CPSFilterResult | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["parameters", b"parameters", "result", b"result"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["parameters", b"parameters", "result", b"result"]) -> None: ...

global___CPSFilterInfo = CPSFilterInfo

@typing.final
class FilterResults(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SIMULATOR_FIELD_NUMBER: builtins.int
    BLOCK_FINDER_FIELD_NUMBER: builtins.int
    REVERSE_ENGINEER_FIELD_NUMBER: builtins.int
    LIN_RECUR_FIELD_NUMBER: builtins.int
    CTL_FIELD_NUMBER: builtins.int
    BACKTRACK_FIELD_NUMBER: builtins.int
    CPS_FIELD_NUMBER: builtins.int
    @property
    def simulator(self) -> global___SimulatorInfo:
        """parameters, results and stats from various filters."""

    @property
    def block_finder(self) -> global___BlockFinderInfo: ...
    @property
    def reverse_engineer(self) -> global___FilterInfo: ...
    @property
    def lin_recur(self) -> global___LinRecurFilterInfo: ...
    @property
    def ctl(self) -> global___CTLFilterInfo: ...
    @property
    def backtrack(self) -> global___BacktrackFilterInfo: ...
    @property
    def cps(self) -> global___CPSFilterInfo: ...
    def __init__(
        self,
        *,
        simulator: global___SimulatorInfo | None = ...,
        block_finder: global___BlockFinderInfo | None = ...,
        reverse_engineer: global___FilterInfo | None = ...,
        lin_recur: global___LinRecurFilterInfo | None = ...,
        ctl: global___CTLFilterInfo | None = ...,
        backtrack: global___BacktrackFilterInfo | None = ...,
        cps: global___CPSFilterInfo | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["backtrack", b"backtrack", "block_finder", b"block_finder", "cps", b"cps", "ctl", b"ctl", "lin_recur", b"lin_recur", "reverse_engineer", b"reverse_engineer", "simulator", b"simulator"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["backtrack", b"backtrack", "block_finder", b"block_finder", "cps", b"cps", "ctl", b"ctl", "lin_recur", b"lin_recur", "reverse_engineer", b"reverse_engineer", "simulator", b"simulator"]) -> None: ...

global___FilterResults = FilterResults

@typing.final
class TMRecord(google.protobuf.message.Message):
    """The top level message for a TM. It contains:
     * TM specification (ttable)
     * Results for all simulations and filters that have been run
     * Concluded "Statuses" for Halting, etc. conditions
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SPEC_VERSION_FIELD_NUMBER: builtins.int
    TM_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    ELAPSED_TIME_US_FIELD_NUMBER: builtins.int
    spec_version: builtins.int
    """Version of the specification this Protobuf was written for.
    Version only needs to change in case non-backwards/forwards compatible
    changes are made to the specification (changing message hierarchy or
    tag numbers).
    """
    elapsed_time_us: builtins.int
    """Total time spent on this TM (across all filters).
    TODO: For now it will be reset each time we run a filter, change this to
    add each time.
    """
    @property
    def tm(self) -> global___TuringMachine: ...
    @property
    def status(self) -> global___BBStatus:
        """Status of this machine with respect to BB, BBB, etc. criteria."""

    @property
    def filter(self) -> global___FilterResults:
        """Detailed results and stats for all filters run."""

    def __init__(
        self,
        *,
        spec_version: builtins.int = ...,
        tm: global___TuringMachine | None = ...,
        status: global___BBStatus | None = ...,
        filter: global___FilterResults | None = ...,
        elapsed_time_us: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["filter", b"filter", "status", b"status", "tm", b"tm"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["elapsed_time_us", b"elapsed_time_us", "filter", b"filter", "spec_version", b"spec_version", "status", b"status", "tm", b"tm"]) -> None: ...

global___TMRecord = TMRecord
